# DEPENDENCY RESOLVER

### Запуск контейнеров
<Папка утилиты>/docker/start-script.sh

### Запуск контейнеров внутри контура
Не занесено. Можно запустить jar собрав самостоятельно или обратившись к автору.

###### Подробное описание в файле ADRs/ADR2-correction-main-principles.md

#### Подробности реализации для решения
1. Реализация вне контура безопасности.
2. Поставляться для использования в качестве образов _docker_ (**DependencyExplorer**
   распространяется вне контура, а **NexusExplorer** должен быть загружен в контур безопасности). Для
   **NexusExplorer** должен быть предусмотрен вариант поставки в виде `fat jar`.
3. В качестве входных и выходных данных используются файлы с определенными именами в заранее
   определенных локациях, которые будут маунтиться к контейнеру.

#### Рабочий процесс получения списка зависимостей для занесения артефактов
1. Отправить на внешний контур:
    1. Версию градла;
    2. Плагины и их версии;
    3. Список зависимостей необходимых для добавления;
    4. Список зависимостей зависимых от необъодимых для добавления зависимостей и от их зависимостей;
    5. Список зависимостей от которых зависят зависимости необходимые для добавления и их зависимости.
       ###### Примечание – Вместо этого можно отправить файлы _build.gradle_, _gradle-wrapper.properties_, _gradle-wrapper.jar_ c заменой зависимостей которые есть только внутри контура безопасности на их заивсимости. Также в таком варианте необходимо убрать все упоминания `Main` класса, отключить задачу `bootJar` и заменить ссылку на корпоративный nexus ссылкой на [дистрибутив gradle](https://services.gradle.org/distributions/) и указать необходимые репозитории вместо корпоративного nexus.
2. Создать проект _gradle_ (в каталоге который будет примонтирован к контейнеру) со всеми плагинами и зависимостями 
(для проекта с единым модулем это файлы _build.gradle_, _gradle-wrapper.properties_, _gradle-wrapper.jar_), запустить 
контейнер с **DependencyExplorer**, который выведет все скачанные для сборки urlы в сторонних репозиториях, в том
числе транзитивные и их родителей со своими зависимостями, полученными при сборке в контейнере.
   ###### Примечание – Для запуска контейнера необходимо выполнить скрипт start-script.sh из [Запуск контейнеров](https://github.com/whoisacat/DependencyResolver/blob/main/README.MD#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%BE%D0%B2) для своей платформы. В этом же скрипте и `docker-compose.yml` в той же папке при необходимости можно специфицировать `tag` образа и папку для монтирования `volume`.
3. Отправить зависимости во внутренний контур.
4. Запустить во внутреннем контуре **NexusExplorer**, который выдаст список отсутствующих в nexus
   зависимостей в файл `out.txt`. Запуск **NexusExplorer** производится в `docker` контейнере или командой 
`java -jar <Имя jar файла собранного в контуре или собранного вне контура и переданного в него>`. При запуске 
**NexusExplorer** ему будет необходим файл с URL nexus, данными для аутентификации в nexus и по размещению SSL 
сертефикатов. Пример содержимого:

`url:::<Протокол://Доменное имя/repository/какой репозиторий/>`  
`username:::Имя пользователя`  
`password:::пароль`  
`ssl:::com.sun.security.enableAIAcaIssuers=true`  
`ssl:::javax.net.ssl.trustStore=<путь до доверенного хранилища>`  
`ssl:::javax.net.ssl.trustStorePassword=<пароль от хранилища>`  

5. Дальше по существующим процессам.